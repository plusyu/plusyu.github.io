---
layout: post
title: IOS 音频处理（二）
categories: [ios]
tags: [ios]
description: ios 音频处理
---


<h1>I / O没有渲染回调函数</h1>

---------------------------------------------------------------------------------------------------------------------------------


添加远程I/ O单元的元件之间的一个或多个其它的音频设备可以让你构建一个更有趣的应用程序。例如，您可以使用多通道混音器单元，输入麦克风位置 音频的立体声场，或提供输出音量控制。在这种设计模式，但仍然没有回调功能在游戏中，如图2-2所示。这简化了图案而限制了它的应用。如果没有渲染 
回调函数，你不必直接操作音频的手段


在这个模式中，您可以配置就像你在直通模式做远程I/ O单元的两个元素。要建立多通道混音器装置，您必须将您的流格式的采样率，调音台输出，如图2-2所示。


混频器的输入流格式自动传输从远程I/ O单元的输入元件的输出建立的，由音频单元的连接方式。同样，对于远程I/ O单元的输出元件的输入范围的流格式由音频单元连接，从调音台输出单元建立，归功于传播


在这种模式的任何实例，的确，当你使用其他音频设备，除了一个I/ O单元，则必须在AudioUnit属性参考说明设置kAudioUnitProperty_MaximumFramesPerSlice属性


与pass-through pattern，你不需要配置任何音频数据缓冲区


<h1>I/O with a Render Callback Function</h1>


通过远程I / O单元的输入和输出元件，可以之间放置呈现回调函数处理传入的音频之前到达输出硬件。在一个非常简单的例子，你可以使用呈现回调函数来调节输出音量。但是，您可以添加颤音，环形调制，回声， 
或其他效果。通过利用傅里叶变换和卷积功能可以在加速框架（见加速框架参考），你的可能性是无限的。这个图案中所描绘图2-3。


正如你在图中看到，这种模式采用远程I/ O单元的两个元素，如本章前面的图案。附上您呈现回调函数来输出元件的输入范围。当该元素需要另一个组音频采样值，它会调用回调函数。您的回调，反过来，获得新鲜的样品通过调用渲染的远程I/ O单元的输入元素的回调函数。


正如其他I/ O模式，你必须明确地允许输入的远程I / O单元，因为输入默认情况下禁用。并且，至于其他的I / O模式，不需要配置任何音频数据缓冲区。


请注意，当您从一个音频单元建立另一个使用的是呈现回调函数的音频通道，在这个模式中，回调需要一个音频单元连接的地方。


<h1>Output-Only with a Render Callback Function</h1>

选择这种模式的音乐游戏和合成器，应用程序要为其生成声音和需要最大的响应。简单地说，这种模式涉及到一个渲染回调函数连接直接到远程I / O单元的输出元件的输入范围，如图2-4


您可以使用同样的模式来提供更复杂的音频结构，构建一个应用程序。例如，您可能要生成几个声音，将它们混合在一起，然后通过该设备的输出播放它们 
硬件。图2-5显示了这种情况。这里，图案采用的音频处理图形和两个额外的音频设备，多通道混音器和iPod的EQ。


在图中，注意到了iPod的EQ要求您在输入和输出设置全码流格式。多通道混频器，另一方面，只需要正确的采样率可以在其输出端设置的。该全码流格式，然后通过混频器的输出的音频单元连接到输入传播 
远程I / O单元的输出元件的范围。这些使用情况的信息，并使用各种的其他具体iOS的音频设备，“使用特定的音频单元”（第41页）中描述。



对于每个多通道混频器单元的输入，如图2-5所见，完整的流格式被设置。对于输入0，则显式地设置它。为输入1时，格式由从音频单元连接传播输出iPod的EQ单位。在一般情况下，你必须考虑到每一个音频单元的流格式的需求单独


还有其他两个主要的设计模式音频设备托管。记录或分析音频，创建一个输入唯一的应用程序与渲染回调函数。回调函数是由应用程序调用的，它又调用远程I/ O单元的输入元素的渲染方法。然而，在大多数情况下，有较好的 

像这样的应用程序的选择是使用实例使用的输入音频队列对象（类型AudioQueueRef在AudioQueueNewInput功能），在音频队列服务编程指南解释。使用 音频队列对象提供了很大的灵活性更因为它呈现回调函数是不是在 

实时线程。 执行脱机音频处理，使用一个通用的输出单位。不同的是远程I/ O单元，这个音频单元 无法连接到设备的音频硬件。当你用它来发送音频到你的应用程序，它 取决于你的应用程序来调用它的渲染方法。


<h1>Constructing Your App</h1>


No matter which design pattern you choose, the stepsfor constructing an audio unit hosting app are basically
the same:

1. Configure your audio session.

2. Specify audio units.

3. Create an audio processing graph, then obtain the audio units.

4. Configure the audio units.

5. Connect the audio unit nodes.

6. Provide a user interface.

7. Initialize and then start the audio processing graph


Configure Your Audio Session

在建立一个音频单元的应用程序的第一个步骤是相同的步骤作为任何iOS的音频应用：你配置音频会议。音频会话的特点在很大程度上决定你的应用程序的音频 
能力以及其交互性与系统的其余部分。开始通过指定的采样率，你想在你的应用程序中使用，如下所示：

self.graphSampleRate = 44100.0; // Hertz


接着，使用所述音频会话对象来请求系统使用所需的采样率的装置硬件采样率，在上市2-1所示。这里的目的是为了避免与采样率转换硬件和您的应用程序。这最大限度地提高CPU的性能和音质，并最大限度地减少电池 
流失。

Listing 2-1 Configuring an audio session


NSError *audioSessionError = nil;

AVAudioSession *mySession = [AVAudioSession sharedInstance]; // 1

[mySession setPreferredHardwareSampleRate: graphSampleRate // 2

 error: &audioSessionError];

[mySession setCategory: AVAudioSessionCategoryPlayAndRecord // 3

 error: &audioSessionError];

[mySession setActive: YES // 4

 error: &audioSessionError];

self.graphSampleRate = [mySession currentHardwareSampleRate]; // 5



1，获取一个参考单音频会话对象的应用程序。 

2，请求硬件采样率。该系统可以或可以不能够准许该请求，这取决于 
在设备上的其它音频活性。 

3，请求你想要的音频会话类别。在“播放和录制”类别，在这里指定，支持 
音频输入和输出。 

4，请激活您的音频会议。 

5，音频会话激活后，根据实际采样率更新自己的采样率变由系统提供的。


还有，你可能想配置一台等硬件特性：音频硬件I/ O缓冲时间。默认持续时间大约是23毫秒在44.1 kHz采样率，相当于1,024个样本的切片大小。如果 
I / O延迟是在你的应用程序的关键，你可以要求一个较小的时间，下降到约0.005毫秒（相当于 256个样本），如下所示：


self.ioBufferDuration = 0.005;

[mySession setPreferredIOBufferDuration: ioBufferDuration

 error: &audioSessionError];


 在运行时，您的音频会话配置代码运行后，你的应用程序还没有获得的音频单元。您可以指定要使用的AudioComponentDescription结构的每一个。请参见“使用标识符 
指定和获得音频单元“（13页）如何做到这一点。该标识键的每个iOS的音频单元列在“标识按键音频单元”（第46页）。


Build an Audio Processing Graph


1. Instantiate an AUGraph opaque type. The instance represents the audio processing graph.

2. Instantiate one or more AUNode opaque types, each of which represents one audio unit in the graph.

3. Add the nodes to the graph.

4. Open the graph and instantiate the audio units.

5. Obtain references to the audio units.


清单2-2显示了如何在包含远程I / O单元和多通道图形执行这些步骤龙头股。它假定你已经定义了一个AudioComponentDescription结构，所有这些音频单元。

Listing 2-2 Building an audio processing graph

{% highlight ruby %}

AUGraph processingGraph;

NewAUGraph (&processingGraph);

AUNode ioNode;

AUNode mixerNode;

AUGraphAddNode (processingGraph, &ioUnitDesc, &ioNode);

AUGraphAddNode (processingGraph, &mixerDesc, &mixerNode);


该AUGraphAddNode函数调用利用音频单元的说明符ioUnitDesc和mixerDesc。在这一点上，图被实例化，并拥有，你会在你的应用程序中使用的节点。以打开该图并 实例化音频设备，通话AUGraphOpen：
AUGraphOpen (processingGraph);

通过AUGraphNodeInfo 获取aduio unit 的引用


AudioUnit ioUnit;

AudioUnit mixerUnit;

AUGraphNodeInfo (processingGraph, ioNode, NULL, &ioUnit);

AUGraphNodeInfo (processingGraph, mixerNode, NULL, &mixerUnit);

{% endhighlight %}
该ioUnit和mixerUnit变量现在持有音频单元实例，从而使您可以配置，然后相互连接音频设备。

<h1>Configure the Audio Units</h1>


<h1>Write and Attach Render Callback Functions</h1>

当声音不流畅。you can attach a render callback immediately by using the audio unit API, as shown in Listing 2-3.
{% highlight ruby %}
AURenderCallbackStruct callbackStruct;

callbackStruct.inputProc = &renderCallback;

callbackStruct.inputProcRefCon = soundStructArray;

AudioUnitSetProperty (

 myIOUnit,

 kAudioUnitProperty_SetRenderCallback,

 kAudioUnitScope_Input,

 0, // output element

 &callbackStruct,

 sizeof (callbackStruct)

);

您可以通过使用音频连接渲染回调的线程安全的方式，即使音频流，处理图形API。清单2-4显示了如何。

Listing 2-4 Attaching a render callback in a thread-safe manner

AURenderCallbackStruct callbackStruct;

callbackStruct.inputProc = &renderCallback;

callbackStruct.inputProcRefCon = soundStructArray;

AUGraphSetNodeInputCallback (

 processingGraph,

 myIONode,

 0, // output element

 &callbackStruct

);

// ... some time later

Boolean graphUpdated;

AUGraphUpdate (processingGraph, &graphUpdated);
{% endhighlight %}

<h1>Connect the Audio Unit Nodes</h1>

在大多数情况下,它是最好的，更容易建立或打破使用音频设备之间的连接在音频处理图形AUGraphConnectNodeInput和AUGraphDisconnectNodeInput功能 
API。这些函数是线程安全的，避免定义连接的编码开销明确，如你必须在不使用的图形做的。


清单2-5显示了如何将混频器节点的输出连接到使用的音频处理图形API的I/ O单元输出单元的输入。


Listing 2-5 Connecting two audio unit nodes using the audio processing graph API
{% highlight ruby %}
AudioUnitElement mixerUnitOutputBus = 0;

AudioUnitElement ioUnitOutputElement = 0;

AUGraphConnectNodeInput (

 processingGraph,

 mixerNode, // source node

 mixerUnitOutputBus, // source node bus

 iONode, // destination node

 iONode, // destination node

 ioUnitOutputElement // desinatation node element

);

{% endhighlight %}


你可以，或者，建立直接使用音频单元打破音频设备之间的连接属性机制。要做到这一点，使用AudioUnitSetProperty功能随kAudioUnitProperty_MakeConnection财产，如例2-6。此方法要求 
你为每个连接定义AudioUnitConnection结构作为它的属性值。


Listing 2-6 Connecting two audio units directly

{% highlight ruby %}
AudioUnitElement mixerUnitOutputBus = 0;

AudioUnitElement ioUnitOutputElement = 0;

AudioUnitConnection mixerOutToIoUnitIn;

mixerOutToIoUnitIn.sourceAudioUnit = mixerUnitInstance;

mixerOutToIoUnitIn.sourceOutputNumber = mixerUnitOutputBus;

mixerOutToIoUnitIn.destInputNumber = ioUnitOutputElement;

AudioUnitSetProperty (

 ioUnitInstance, // connection destination

 kAudioUnitProperty_MakeConnection, // property key

 kAudioUnitScope_Input, // destination scope

 ioUnitOutputElement, // destination element

 &mixerOutToIoUnitIn, // connection definition

 sizeof (mixerOutToIoUnitIn)

);
{% endhighlight %}
在这点上构建的应用程序，该音频单元，并且，典型地，音频处理图形的完全构建和配置。在许多情况下，你会再想要提供一个用户界面，让用户微调音频行为。您定制的用户界面，以允许用户调整特定的音频单元的参数 
并且，在某些特殊的情况下，音频单元的属性。在任一情况下，用户界面​​还应该提供视觉关于当前设置意见


而iPod的EQ单位是不寻常的病例在一，改变它的有源均衡曲线，您可以更改在kAudioUnitProperty_PresentPreset属性值。你可以这样做音频是否运行。对于一个工作示例，请查看示例代码项目iPhoneMixerEQGraphTest。


Using I/O Units

{% highlight ruby %}


<p>Audio unit  feature              |              Details</p>



<p>Elements                         |      	  一个input element: element 1.</p>
<p>										   一个output element :element 0.</p>
<p>									     	默认情况下，input elements 是关闭的</p>
<p>										    output elements 是开启的。</p>
<p></p>
<p>								 |		    使用kAudioOutputUnitProperty_EnableIO属性来设置</p>



<p>
推荐的 stream format attributes   |		■ kAudioFormatLinearPCM</p>
<p></p>
<p>								 |		■ AudioUnitSampleType</p>
<p></p>
<p>								 |		■ kAudioFormatFlagsAudioUnitCanonical</p>
<p></p>
<p>------------------------------------------------------------------------------------</p>
<p></p>
<p></p>
<p>Property notes                   |  	You 必须设置 kAudioUnitProperty_MaximumFramesPerSlice</p>
<p>											property on this audio unit.</p>
<p>-------------------------------------------------------------------------------------</p>

{% endhighlight %}
<h1>Generic Output Unit</h1>

发送的输出时 
音频处理图形到您的应用程序而不是输出音频硬件。您通常会 
使用通用输出单元为离线音频处理。就像其他的I / O单元，通用输出单元 
集成了格式转换器单元。这让通用输出单元之间进行格式转换 
在音频处理图形和所需的格式使用的流格式。


<h1>Using Mixer Units</h1>

iOS提供了两个混频器单元。在大多数情况下，你应该使用多通道混音器单元，它提供了 
混合任意数量的单声道或立体声数据流。如果你需要的3D Mixer unit 的特征，你应该 
很可能是使用OpenAL的代替。 OpenAL的是建立在三维混合器单元的顶部，提供了等效
性能与更简单的API，它非常适合于游戏应用开发。

<h1>Multichannel Mixer Unit</h1>

多通道混音器单元（(subtype kAudioUnitSubType_MultiChannelMixer）采用任何数量的 
单声道或立体声数据流，并把它们组合成一个单一的立体声输出。它控制的音频增益为每个输入 
和输出，并允许您打开或关闭每个单独的输入。在开始的iOS4.0，多通道 
混频器支持立体声声像每个输入。 
对于示例代码，演示了如何使用这个音频单元，见示例代码项目的调音台（MixerHost）。
{% highlight ruby %}

----------------------------------------------------------------------------------

Audio unit  feature              |	Details

----------------------------------------------------------------------------------
								 |
Elements                         |  一个或多个input elements,其中每一个可以是单声道或立体声。
								 |	一个立体声输出的元素。
								 |
								 |
----------------------------------------------------------------------------------

推荐的 stream format attributes   |  	■ kAudioFormatLinearPCM
								 |		■ AudioUnitSampleType
								 |		■ kAudioFormatFlagsAudioUnitCanonical
----------------------------------------------------------------------------------

Stream format notes              |      所输入的范围，管理流的格式如下： 

										■如果一个输入总线是由一个音频单元连接供给，它获取其流 
										格式从该连接。 

										■如果输入总线由呈现回调函数喂，设置完成 
											总线上的应用数据流的格式。使用相同的流格式中所用的 
											对于由回调所提供的数据。 
											在输出范围，只设置应用程序的采样率。


----------------------------------------------------------------------------------

Property notes                   |  	<p>默认情况下，kAudioUnitProperty_MaximumFramesPerSlice属性 
										设定为1024，这是不足够的，当该屏幕的锁和 
										显示器处于休眠状态。如果您的应用程序播放音频与屏幕锁定时，则必须增加 
										此属性除非音频输入的值是有效的。具体操作如下：
										</p>	
										<p>
										■如果音频输入处于活动状态，你不需要设置的值 
										kAudioUnitProperty_MaximumFramesPerSlice。</p> 
											<p>
										■如果音频输入处于非活动状态，则此属性设置为4096的值。</p>


------------------------------------------------------------------------------------
{% endhighlight %}
<h1>3D Mixer Unit</h1>

3D Mixer unit (subtype kAudioUnitSubType_3DMixer)控制的立体声声像，播放速度，并 
获得对于每个输入，并控制其他的特性，如对听者表观距离。输出 
具有音频增益控制。要得到这个音频单元可以做一些想法，认为OpenAL的iOS中是 
用它来实现。

在大多数情况下，如果你需要3D Mixer unit的特点，你最好的选择是使用OpenAL的。样品 
代码显示了如何使用OpenAL的，见示例代码项目oalTouch。对于示例代码所示 
如何直接使用3D Mixer unit，见示例代码项目Mixer3DHost。


<p>------------------------------------------------------------------------------------</p>

<p>Audio unit  feature              |                           Details</p>

<p>------------------------------------------------------------------------------------</p>

<p>Elements                         |     一个或多个输入元素，每一个是单声道。一个立体声输出元</p>


<p>------------------------------------------------------------------------------------</p>


<p>推荐的 stream format attributes   |  	■ UInt16</p>

	<p>							 |		■ kAudioFormatFlagsCanonical</p>


<p>------------------------------------------------------------------------------------</p>

<p>Stream format notes              |     所输入的范围，管理流的格式如下： </p>
<p>										■如果一个输入总线是由一个音频单元连接供给，它获取其流 
										格式从该连接。 </p>

<p>										■如果输入总线由呈现回调函数喂，设置完成 
										总线上的应用数据流的格式。使用相同的流格式中所用的 
										对于由回调所提供的数据。 </p>
<p>										在输出范围内，仅有应用程序的采样率</p>

<p>------------------------------------------------------------------------------------</p>

<p>Property notes                   |  	默认情况下，kAudioUnitProperty_MaximumFramesPerSlice属性 
										设定为1024，这是不足够的，当该屏幕的锁和 
										显示器处于休眠状态。如果您的应用程序播放音频与屏幕锁定时，则必须增加 
										此属性除非音频输入的值是有效的。具体操作如下：</p>

<p>										■如果音频输入处于活动状态，你不需要设置的值 
										kAudioUnitProperty_MaximumFramesPerSlice。 </p>

<p>										■如果音频输入处于非活动状态，则此属性设置为4096的值。</p>


<p>------------------------------------------------------------------------------------</p>


<h1>Using Effect Units</h1>
 iPod EQ unit （subtype kAudioUnitSubType_AUiPodEQ）是iOS的4本所提供的唯一效果器 
是使用内置的iPod应用程序相同的均衡器。

<p>------------------------------------------------------------------------------------</p>

<p>Audio unit  feature              |                           Details</p>

<p>------------------------------------------------------------------------------------</p>

<p>Elements                         |     一个或多个输入元素，每一个是单声道。一个立体声输出元</p>


<p>------------------------------------------------------------------------------------</p>


<p>推荐的 stream format attributes   |  	■ kAudioFormatLinearPCM</p>

<p>								 |		■ AudioUnitSampleType</p>

<p>								 |		■ kAudioFormatFlagsAudioUnitCanonical</p>



<p>------------------------------------------------------------------------------------</p>

<p>Stream format notes              |     所输入的范围，管理流的格式如下： </p>
		<p>								■如果一个输入总线是由一个音频单元连接供给，它获取其流 
										格式从该连接。 </p>

	<p>									■如果输入总线由呈现回调函数喂，设置完成 
										总线上的应用数据流的格式。使用相同的流格式中所用的 
										对于由回调所提供的数据。 
										在输出范围内，仅有应用程序的采样率</p>

<p>------------------------------------------------------------------------------------</p>

<p>Property notes                   |  	默认情况下， iPod EQ unit提供了一组预定义的色调均衡曲线，通过访问kAudioUnitProperty_FactoryPresets。
											然后，您可以申请设置 
											用它作为用于kAudioUnitProperty_PresentPreset属性的值。 
											默认情况下，kAudioUnitProperty_MaximumFramesPerSlice属性 
											设定为1024，这是不足够的，当屏幕锁定和显示 
											睡觉。如果您的应用程序播放音频与屏幕锁定时，你必须增加值 
											这个属性，除非音频输入有效。具体操作如下： </p>
<p>											■如果音频输入处于活动状态，你不需要设置的值 </p>
											kAudioUnitProperty_MaximumFramesPerSlice财产。 </p>
<p>											■如果音频输入处于非活动状态，则此属性设置为4096的值</p>


<p>------------------------------------------------------------------------------------</p>


<h1>Identifier Keys for Audio Units</h1>

{% highlight ruby %}
-------------------------------------------------------------------------------------------------------
Name and description         							Identifier keys      			 Corresponding  four-char codes
Converter unit

Supports audio format conversions to or                 kAudioUnitType_FormatConverter      aufc
from linear PCM.										kAudioUnitSubType_AUConverter       conv
														kAudioUnitManufacturer_Apple        appl
-------------------------------------------------------------------------------------------------------
iPod Equalizer unit                                     kAudioUnitType_Effect

Providesthe features of the iPod equalizer              kAudioUnitSubType_AUiPodEQ

														kAudioUnitManufacturer_Apple
-------------------------------------------------------------------------------------------------------

3D Mixer unit 											kAudioUnitType_Mixer

														kAudioUnitSubType_-


Supports mixing multiple audio streams,					AU3DMixerEmbedded


output panning, sample rate conversion,					kAudioUnitManufacturer_Apple
and more.						

-------------------------------------------------------------------------------------------------------										

Multichannel Mixer unit                                 kAudioUnitType_Mixer

Supports mixing multiple audio streams                  kAudioUnitSubType_-
to a single stream.									    MultiChannelMixer
														
														kAudioUnitManufacturer_Apple

Generic Output unit                                     kAudioUnitType_Output

Supports converting to and from linear                  kAudioUnitSubType_GenericOutput

PCM format; can be used to start and stop               kAudioUnitManufacturer_Apple

a graph.

Remote I/O unit 										kAudioUnitType_Output



Connects to device hardware for input,					kAudioUnitSubType_RemoteIO

output, orsimultaneousinput and output         			kAudioUnitManufacturer_Apple
---------------------------------------------------------------------------------------------------------
{% endhighlight %}













