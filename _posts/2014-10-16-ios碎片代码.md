---
layout: post
title: IOS 碎片代码
categories: [ios]
tags: [ios]
description: ios 碎片
---

1、为控件添加边框

{% highlight ruby %}

UISlider slider= [[UISlider alloc] initWithFrame:CGRectMake(0, 0, 300, 24)];

CALayer *rightBorder = [CALayer layer];

rightBorder.borderColor = [UIColor darkGrayColor].CGColor;

rightBorder.borderWidth = 1;

rightBorder.frame = CGRectMake(-1, -1, CGRectGetWidth(slider.frame), 
                                   CGRectGetHeight(slider.frame)+2);

[slider.layer addSublayer:rightBorder];

[self.view addSubview:slider];

{% endhighlight %}

2、混合使用ARC

build phases中修改compiler Flags
{% highlight ruby %}
不支持ARC

      -fno-objc-arc

支持ARC

       -fobjc-arc

{% endhighlight %}

3、UIView tag

{% highlight ruby %}

enum MyViewTags {
    kTitleLabelTag = 1,
    kSendButtonTag,
    kSomeOtherViewTag
};

// ...

if (sender.tag == kSendButtonTag) {
    // ...
}

{% endhighlight %}

4、读取plist文件

{% highlight ruby %}

 NSArray *pathsArr = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
            NSString *docDir = [pathsArr objectAtIndex:0];
            NSString *newDocDir = [docDir stringByAppendingString:@"/Preferences"];
            NSLog(@"%@", newDocDir);
            NSString *filePath = [newDocDir stringByAppendingPathComponent:@"xxx.plist"];
            NSMutableDictionary* dic = [[NSMutableDictionary alloc] initWithContentsOfFile:filePath];

            NSEnumerator *enumerator = [dic keyEnumerator];
            for(NSString *key in enumerator) {
                NSLog(@"%@", key);
            }

{% endhighlight %}


5、strong 和 weak 

{% highlight ruby %}

weak 使用场景

1、delegate properties  

2、subviews 和 view controller's main view

strong 

强引用就像是有N条线的风筝

线就相当于是retain count 。

只有还有一个人放着风筝，风筝就不会飘走。

当所有人都放开手中的线，调用dealloc。

weak 相当于看别人放风筝。当有人放风筝的时候，你可以看（访问它的属性和方法），但是风筝不受你的控制，因为你手中并没有
风筝的线（retain count）。当所有线都断开的时候，看sky big（delloc）去。

{% endhighlight %}


6、自定义返回按钮

{% highlight ruby %}

	//自定义返回按钮
	UIImage *backButtonImage = [[UIImage imageNamed:@"fanhui.png"] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 30, 0, 0)];
	[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];
	//将返回按钮的文字position设置不在屏幕上显示
	[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];

{% endhighlight %}

7、 iOS Simulator 

{% highlight ruby %}

 command + s  Copy Screen to (~/Desktop)

{% endhighlight %}

8、frame、bounds、center

{% highlight ruby %}

-(CGRect) frame  
{  
     float x = center.x - layer.anchorPoint.x * bounds.width;   
     float y = center.y - layer.anchorPoint.y * bounds.height;  
     float width = bounds.width;
     float height = bounds.height;  
     return CGRectMake(x, y, width, height);
}

-(void) setFrame:(CGRect) rect
{
    center.x = rect.x + layer.anchorPoint.x * rect.width;
    center.y = rect.y + layer.anchorPoint.y * rect.height;
    bounds.width = rect.width;
    bounds.height = rect.height;
}

默认anchorPoint:(0.5,0.5)
改变anchorPoint的时候,center不会改变。frame会随着发生改变
--------------------------------------------------------------------


frame: 该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）
bounds：该view在本地坐标系统中的位置和大小。（参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）
center：该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）

UIView *aView = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 300, 300)];
[aView setBounds:CGRectMake(50, 50, 500, 500)];

UIView *bView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
[aView addSubview:bView];

bView左上平移(-50,-50)；

bounds.width和bounds.height就是aView的width和height。覆盖上面的initWithFrame。

bounds.x和bounds.y只控制aView下所有subView的原点坐标。

默认center： view.width/2,view.height/2
改动
aView.center = CGPointMake(100,100);
aView的位置向左下移动了(100-300/2, 125-300/2)距离

center只改变位置，不改变大小。



任何时候：
layer.position === center

{% endhighlight %}

9、定位EXC_BAD_ACCESS

{% highlight ruby %}

	Product-->Scheme-->>Edit Scheme-->Environment Variables

	下添加NSZombieEnabled ＝ YES

{% endhighlight %}

