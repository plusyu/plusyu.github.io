---
layout: post
title: IOS 碎片知识
categories: [ios]
tags: [ios]
description: ios 碎片知识
---



1、使用类成员时，前面加不加self.有什么区别

{% highlight ruby %}

//.h
@property (nonatomic, retain) NSString *name
 
//.m
name = @"bang"  //没有retain，随时会被释放
NSString *str = self.name  //等于NSString *str = [self name];
self.name = @"bang" //等于[self setName:@"bang"]; 这时在set方法里retain了这个字符串

{% endhighlight %}

2、使用block还是delegate编写回调代码遵循以下几点：

<pre class="prettyPrint">

如果一个delegate只有几个方法，比如只是提交和取消，推荐使用block编写动作响应代码。

Ø   如果对象存在多个不同事件，则应该使用代理模式编写各事件的处理代码

Ø   如果对象是单例，应该使用block，而不是代理。

Ø   如果对象是为了其他的信息而进行回调，则使用代理。

Ø   代理更多的是面向于过程，而block则更多的面向于结果。

</pre>

3、GCD NSOperation

{% highlight ruby %}


GCD在多核CPU上线程切换的时间比较短,效率相对高些.

NSOperation是建立在GCD之上的,虽然使用起来比较复杂 但是在线程并发管理、优先级上有着GCD无法比拟的优势.

可以非常好地控制队列长度和并发的网络数量。

GCD 在块分派之后就无法取消了。

{% endhighlight %}

4、nil Nil NULL NSNull

<pre class="prettyPrint">

NULL表示C指针中的空值

{% highlight ruby %}

charchar *string = NULL;

{% endhighlight %}

nil用于表示指向Objective-C中对象的指针的值为空

{% highlight ruby %}

NSString *string = nil;

id anyObject = nil;

{% endhighlight %}


Nil用于表示Objective-C类（Class）类型的变量值为空


Class anyClass = Nil;

{% highlight ruby %}

NSNull是一个Objective-C类，只不过这个类相当特殊，因为它表示的是空值，即什么都不存。

这是NSArray中只会保存wang和zz两个字符串，foogry字符串会被抛弃。

NSArray *arr = [NSArray arrayWithObjects:@"wang",@"zz",[NSNull null],@"foogry"];

{% endhighlight %}

</pre>


