---
layout: post
title: IOS 代码规范
categories: [ios]
tags: [ios]
description: ios 代码细节
---


{% highlight ruby %}

@interface Foo : NSObject
 
@property(strong, nonatomic) NSObject* myObj;
 
@end
 
// …
 
@implementation Foo
 
@synthesize myObj = myObj_;
 
@end

{% endhighlight %}

{% highlight ruby %}

@interface Foo : NSObject
 
@property(strong, nonatomic) Bar* myObj;
 
@end
 
// …
 
@implementation Foo
 
@synthesize myObj = myObj_;
 
- (void)someMethod
{
        self.myObj = [[Bar alloc] init];
}
 
@end

{% endhighlight %}



BAD

{% highlight ruby %}

//
// Foo.h
//
 
@interface Foo : NSObject
 
@property(nonatomic) int myPublicProperty;
@property(strong, nonatomic) Bar* myPrivateProperty; // This can be accessed by anyone who includes the header
 
- (int)myPublicMethod;
- (int)myPrivateMethod; // So can this.
 
@end

{% endhighlight %}

BETTER

{% highlight ruby %}

//
// Foo.h
//
 
@interface Foo : NSObject
 
// Only the public API can be accessed by including the header
 
@property(nonatomic) int myPublicProperty;
 
- (int)myPublicMethod;
 
@end



//
// Foo.m
//
 
@interface Foo () // This is a "class extension" and everything declared in it is private, because it’s in the implementation file
 
@property(strong, nonatomic) Bar* myPrivateProperty;
 
- (int)myPrivateMethod;
 
@end
 
@implementation Foo
// …
@end

{% endhighlight %}



{% highlight ruby %}


BAD
@implementation Foo
 
@synthesize myTimer;
 
- (void)dealloc
{
        self.myTimer = nil; // Timer not invalidated, we could get called back if the timer fires after we’re dealloced!
}
 
@end



BETTER
@implementation Foo
 
@synthesize myTimer = myTimer_;
 
- (NSTimer*)myTimer
{
        return myTimer_;
}
 
- (void)setMyTimer:(NSTimer*)myTimer
{
        [myTimer_ invalidate];
        myTimer_ = myTimer;
}
 
- (void)dealloc
{
        self.myTimer = nil; // Timer guaranteed not to fire after we’re gone! Still necessary under ARC.
}
 
@end


ARC takes care of releasing your (strong) or (retain) instance variables at -dealloc time, but it does it directly, rather than by calling your custom setters. So if your custom setters have other side effects (like invaliding timers) you must still make sure to invoke them yourself.


NEVER call -drawRect on a UIView yourself. Call -setNeedsDisplay.



NEVER use method names like -drawUI when you aren’t really drawing anything.

ALWAYS prefer names like -setupUI or -resetUI, especially if there’s the possibility the method can be called more than once.

{% endhighlight %}

